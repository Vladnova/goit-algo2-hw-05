# Завдання 1: Перевірка унікальності паролів за допомогою фільтра Блума

## Опис

Цей проект реалізує перевірку унікальності паролів за допомогою **фільтра Блума**. Завдяки цьому підходу ви можете перевіряти, чи використовувався пароль раніше, без необхідності зберігати самі паролі. Це дозволяє заощадити пам'ять і забезпечити ефективну перевірку на унікальність, навіть для великих наборів даних.

## Технічні умови

1. **Клас BloomFilter**:
    - Клас реалізує основну логіку роботи з фільтром Блума, включаючи додавання елементів і перевірку наявності елементів.
    - Використовуються кілька хеш-функцій для зменшення ймовірності помилкових спрацьовувань.

2. **Функція `check_password_uniqueness`**:
    - Функція приймає екземпляр фільтра Блума та список нових паролів.
    - Перевіряє кожен пароль на унікальність, використовуючи фільтр Блума.
    - Повертатиме результат для кожного пароля: "новий" або "повторюється".

3. **Обробка даних**:
    - Паролі обробляються як рядки.
    - Порожні або некоректні значення паролів також обробляються належним чином.
    - Програма забезпечує мінімальне використання пам'яті та може працювати з великими наборами даних.

## Як використовувати

1. Ініціалізуйте фільтр Блума, вказавши розмір і кількість хеш-функцій:

    ```aiignore
    bloom = BloomFilter(size=1000, num_hashes=3)
    ```

2. Додайте існуючі паролі до фільтра:

    ```aiignore
    existing_passwords = ["password123", "admin123", "qwerty123"]
    for password in existing_passwords:
        bloom.add(password)
    ```

3. Перевірте нові паролі на унікальність:

    ```aiignore
    new_passwords_to_check = ["password123", "newpassword", "admin123", "guest"]
    results = check_password_uniqueness(bloom, new_passwords_to_check)
    ```

4. Виведіть результати:

    ```aiignore
    for password, status in results.items():
        print(f"Пароль '{password}' - {status}.")
    ```

## Приклад використання

```aiignore
if __name__ == "__main__":
    # Ініціалізація фільтра Блума
    bloom = BloomFilter(size=1000, num_hashes=3)

    # Додавання існуючих паролів
    existing_passwords = ["password123", "admin123", "qwerty123"]
    for password in existing_passwords:
        bloom.add(password)

    # Перевірка нових паролів
    new_passwords_to_check = ["password123", "newpassword", "admin123", "guest"]
    results = check_password_uniqueness(bloom, new_passwords_to_check)

    # Виведення результатів
    for password, status in results.items():
        print(f"Пароль '{password}' - {status}.")
```

# Завдання 2: Порівняння продуктивності HyperLogLog із точним підрахунком унікальних елементів

## Опис

Цей проект реалізує порівняння двох методів підрахунку унікальних елементів: точного підрахунку за допомогою структури `set` та наближеного підрахунку з використанням алгоритму **HyperLogLog**. Для цього використовуються IP-адреси з реального лог-файлу, а також порівнюється час виконання обох методів.

## Технічні умови

1. **Завантаження даних**:
    - Завантаження даних з лог-файлу `lms-stage-access.log`, що містить інформацію про IP-адреси.
    - Ігнорування некоректних рядків під час обробки файлу.

2. **Точний підрахунок**:
    - Використовує структуру даних `set` для точного підрахунку унікальних IP-адрес.

3. **Наближений підрахунок за допомогою HyperLogLog**:
    - Реалізація алгоритму HyperLogLog для наближеного підрахунку унікальних IP-адрес.

4. **Порівняння продуктивності**:
    - Проведення порівняння обох методів за часом виконання, щоб продемонструвати різницю між точним підрахунком і наближеним методом HyperLogLog.

## Як використовувати

1. Завантажте лог-файл `lms-stage-access.log`, що містить дані про IP-адреси.

2. Використовуйте методи для точного підрахунку та підрахунку з HyperLogLog:

    ```aiignore
    # Точний підрахунок
    exact_count = count_unique_ips_exact('lms-stage-access.log')

    # Підрахунок за допомогою HyperLogLog
    hyperloglog_count = count_unique_ips_hyperloglog('lms-stage-access.log')
    ```

3. Порівняйте результати:

    ```aiignore
    print("Точний підрахунок:", exact_count)
    print("HyperLogLog:", hyperloglog_count)
    ```

4. Результати порівняння за часом виконання:

    ```aiignore
    results = compare_performance('lms-stage-access.log')
    print(results)
    ```

## Приклад використання

```aiignore
if __name__ == "__main__":
    # Завантаження даних та точний підрахунок
    exact_count = count_unique_ips_exact('lms-stage-access.log')

    # Наближений підрахунок за допомогою HyperLogLog
    hyperloglog_count = count_unique_ips_hyperloglog('lms-stage-access.log')

    # Порівняння результатів
    results = compare_performance('lms-stage-access.log')

    # Виведення результатів
    print("Точний підрахунок:", exact_count)
    print("HyperLogLog:", hyperloglog_count)
    print("Результати порівняння:", results)
```